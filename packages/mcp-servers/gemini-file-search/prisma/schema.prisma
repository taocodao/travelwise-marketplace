generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String        @id @default(uuid())
  walletAddress String        @unique @map("wallet_address")
  balance       Decimal       @default(0) @db.Decimal(18, 6)
  nonce         Int           @default(0)
  isActive      Boolean       @default(true) @map("is_active")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")
  
  notebooks         Notebook[]
  oauthConnections  OAuthConnection[]
  sourceSelection   UserSourceSelection?
  
  @@index([walletAddress])
  @@map("users")
}

// User's persisted source selection for Q&A
model UserSourceSelection {
  id        String   @id @default(uuid())
  userId    String   @unique @map("user_id")
  sourceIds String[] @map("source_ids")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_source_selections")
}

model Notebook {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  name        String
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sources     Source[]
  queryAnswers QueryAnswer[]
  
  @@index([userId])
  @@map("notebooks")
}

model Source {
  id          String   @id @default(uuid())
  notebookId  String   @map("notebook_id")
  type        String
  name        String
  content     String   @db.Text
  url         String?
  imageData   String?  @db.Text  // Base64 encoded image/file data for visual queries
  mimeType    String?  @map("mime_type")  // MIME type for binary files
  isSelected  Boolean  @default(true) @map("is_selected")
  createdAt   DateTime @default(now()) @map("created_at")
  
  notebook    Notebook @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  chunks      SourceChunk[]
  
  @@index([notebookId])
  @@map("sources")
}

// Document chunks for semantic search (NotebookLM-style RAG)
model SourceChunk {
  id          String   @id @default(uuid())
  sourceId    String   @map("source_id")
  content     String   @db.Text
  chunkIndex  Int      @map("chunk_index")
  embedding   Json?    // Vector embedding for semantic similarity
  createdAt   DateTime @default(now()) @map("created_at")
  
  source      Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  
  @@index([sourceId])
  @@map("source_chunks")
}

// Self-learning cache: stores successful Q&A pairs for fast retrieval
model QueryAnswer {
  id          String   @id @default(uuid())
  notebookId  String   @map("notebook_id")
  question    String
  answer      String   @db.Text
  usageCount  Int      @default(0) @map("usage_count")
  helpful     Boolean?
  source      String   @default("query") // query | learning
  embedding   Json?    // Vector embedding for semantic similarity
  sourceIds   String?  @map("source_ids") // Comma-separated source IDs for cache key
  createdAt   DateTime @default(now()) @map("created_at")
  
  notebook    Notebook @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  
  @@index([notebookId])
  @@map("query_answers")
}

// OAuth connections for GitHub, Google Drive, Notion, etc.
model OAuthConnection {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  provider     String    // github | google | notion
  accessToken  String    @map("access_token")
  refreshToken String?   @map("refresh_token")
  expiresAt    DateTime? @map("expires_at")
  accountEmail String?   @map("account_email")
  accountName  String?   @map("account_name")
  metadata     Json?
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, provider])
  @@index([userId])
  @@map("oauth_connections")
}
